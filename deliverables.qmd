---
title: "AD 6698 Generative AI for Business Analytics"
subtitle: "Deliverables"
number-sections: false
bibliography: references.bib
csl: chicago-syllabus.csl
# html-table-processing: none
---

## Course Schedule 

```{python}
#| echo: false
#| output: markdown

from datetime import datetime, timedelta
import pandas as pd
from IPython.display import display, Markdown

semester = "Spring"

# Function to generate the Day 1 - Day 7 list based on a start date
def generate_days(start_date):
    days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    start_day_index = days.index(start_date)
    days_shifted = days[start_day_index:] + days[:start_day_index]
    return days_shifted

# Start dates for each section
start_dates = {
    "A1": "Monday",
    "O1": "Tuesday",
}


# Initialize the combined table data
combined_data = {"Day": [f"Day {i+1}" for i in range(7)]}

# Generate and add columns for each section
for section, start_date in start_dates.items():
    combined_data[section] = generate_days(start_date)

# Create a single DataFrame
combined_table = pd.DataFrame(combined_data)

# Precompute inline-safe variables
first_section = list(start_dates.keys())[0]
first_day = start_dates[first_section]
last_day_first_section = combined_table.iloc[6, 1]

second_section = list(start_dates.keys())[1]
second_day = start_dates[second_section]
last_day_second_section = combined_table.iloc[6, 2]

# Display the combined table without index
# display(combined_table.style.hide(axis="index"))
combined_table.style.hide(axis="index")

```


- **Section `{python} first_section`**
  - The first day of the week (Day 1) for section `{python} first_section` is [`{python} first_day`]{.uugreen-bold}, this is the day we will conduct our live classroom sessions.
  - The last day of the week (Day 7) for section `{python} first_section` is [`{python} last_day_first_section`]{.uured-bold}.

- **Section `{python} second_section`**
  - The first day of the week (Day 1) for section `{python} second_section` is [`{python} second_day`]{.uugreen-bold}, this is the day we will conduct our live classroom sessions.
  - The last day of the week (Day 7) for section `{python} second_section` is [`{python} last_day_second_section`]{.uured-bold}.


Please adhere to the due dates posted on the course website. [Late work is not accepted]{.bloodred-bold}.

- All assignments (for on campus) will open **one to two weeks before the due date**.
- All assignments (for online) will open **in the first two weeks**.
- All Labs (for on campus) will open **one week before the due date**.
- All Labs (for online) will open **in the first two weeks** and are ungraded.



## Online (O1) Spring

```{python}
#| echo: false
#| eval: false
#| tbl-colwidths: [10,10,15,15]

from datetime import datetime, timedelta
import pandas as pd
from IPython.display import HTML

semester = "Spring25"

# Define Summer sections only (excluding A1, A2, A3)
sections = {
    "A1": "2026-01-27",  # 2026-01-20 Tuesday start
}

# Number of lectures (shorter summer term)
required_lectures = 7

# Class days: Tuesday (1) and Thursday (3)
class_days = [1]  # Monday=0, Sunday=6

# Optional: Summer break or holiday dates
holiday_substitutions = {}  # Add if needed

breaks = {
    "IPD": ("2025-10-13", "2025-10-13"),  # if Thursday is off
}

# Parse break ranges
break_ranges = [
    (datetime.strptime(start, "%Y-%m-%d"), datetime.strptime(end, "%Y-%m-%d"))
    for start, end in breaks.values()
]

# Define course end date (adjust as needed)
end_date = datetime(2025, 10, 17)

# Schedule generation
schedule = {section: [] for section in sections}

for section, start_str in sections.items():
    start_date = datetime.strptime(start_str, "%Y-%m-%d")
    lecture_dates = []
    current_date = start_date

    while len(lecture_dates) < required_lectures:
        if current_date.weekday() in class_days:
            # Check breaks
            if any(start <= current_date <= end for start, end in break_ranges):
                current_date += timedelta(days=1)
                continue

            # Check substitutions
            if current_date in holiday_substitutions:
                lecture_dates.append(holiday_substitutions[current_date])
            else:
                lecture_dates.append(current_date)

        current_date += timedelta(days=1)
        if current_date > end_date:
            break

    # Format dates
    schedule[section] = [d.strftime("%d-%b (%a)") for d in sorted(lecture_dates)]

# Insert as a new column

# Create DataFrame
schedule_df = pd.DataFrame(schedule)
# schedule_df.insert(0, "#", [f"L{i+1}" for i in range(required_lectures)])

# # Create lab strings only for the first 8 lectures
# lab_entries = [
#     f"Lab {i+1}" if i < 8 else ""
#     for i in range(len(schedule_df))
# ]
# schedule_df["Lab"] = lab_entries

# Set class day index (Monday = 0)
class_day_index = 1

# Identify lectures on the chosen class day
classday_lectures = [(i, d) for i, d in enumerate(lecture_dates) if d.weekday() == class_day_index]

# Select up to 4 lectures for assignment release (every 2 weeks, starting from 2nd)
selected_assignments = classday_lectures[1::1][:4]  # skip first, then take every 2nd, limit to 4

# Create assignments list
assignments = []
for idx, (i, open_date) in enumerate(selected_assignments):
    due_date = open_date + timedelta(days=1)  # Due on next week's Tuesday/Wednesday
    assignments.append((i, f"A{idx+1} (Due: {due_date.strftime('%b %d')})"))

# Add to DataFrame
assignment_column = [""] * len(schedule_df)
for i, label in assignments:
    assignment_column[i] = label

schedule_df["Assignments"] = assignment_column

selected_project_dates = classday_lectures[1::1][:4]

# Create project milestones aligned with assignment releases
project = []
for idx, (i, _) in enumerate(selected_project_dates):
    project.append((i, f"Ungraded Milestone {idx+1}"))

# Add final project milestone on the last lecture
# Identify last two lecture indices
last_lecture_index = schedule_df.index[-1]
second_last_lecture_index = schedule_df.index[-2]

# Add final presentation label to both
project.append((second_last_lecture_index, ""))
project.append((last_lecture_index, "Final Project Report + Presentation"))

# Create and assign project column
project_column = [""] * len(schedule_df)
for i, label in project:
    project_column[i] = label

schedule_df["Project Milestones"] = project_column

# Create and assign project column
project_column = [""] * len(schedule_df)
for i, label in project:
    project_column[i] = label

schedule_df["Project Milestones"] = project_column

schedule_df["Participation"] = [""] * len(schedule_df)

# Initialize participation entries
participation = []

# Choose the second-to-last lecture (Week 11)
participation_index = schedule_df.index[-2]  # -2 gets the 11th lecture (0-indexed)

# Create empty column
schedule_df["Participation"] = [""] * len(schedule_df)

# Add multi-line text to second-to-last lecture
participation_index = schedule_df.index[-2]
schedule_df.loc[participation_index, "Participation"] = "Participation 1 + Participation 2"

# Export
output_file = f"./data/{semester}_schedule_online.xlsx"
schedule_df.to_excel(output_file, index=False)

# Display HTML
HTML(schedule_df.to_html(index=False))


```


## On Campus (A1) Spring

```{python}
#| echo: false
#| tbl-colwidths: [10,10,15,15]

from datetime import datetime, timedelta
import pandas as pd
from IPython.display import HTML


# Define Spring section A1, starting on Monday Jan 27, 2026
sections = {
    "A1": "2026-01-20",  # Monday start after MLK holiday
}

# Number of lectures
required_lectures = 13

# Class is on Mondays
class_days = [0]  # Monday = 0

# Define relevant breaks
breaks = {
    "PresidentsDay": ("2026-02-16", "2026-02-16"),  # Monday off
}

# Manual substitution for Presidents Day (make-up class on Wednesday, Feb 18)
holiday_substitutions = {
    datetime(2026, 2, 16): datetime(2026, 2, 17)
}

# Define breaks
breaks = {
    "Spring Break": ("2026-03-07", "2026-03-15"),
}


# Parse break ranges
break_ranges = [
    (datetime.strptime(start, "%Y-%m-%d"), datetime.strptime(end, "%Y-%m-%d"))
    for start, end in breaks.values()
]

# Set course end date
end_date = datetime(2026, 4, 30)

# Initialize schedule dictionary
schedule = {section: [] for section in sections}

# Generate schedule
for section, start_str in sections.items():
    start_date = datetime.strptime(start_str, "%Y-%m-%d")
    lecture_dates = []
    current_date = start_date

    while len(lecture_dates) < required_lectures:
        # Handle substitutions
        if current_date in holiday_substitutions:
            lecture_dates.append(holiday_substitutions[current_date])
        elif current_date.weekday() in class_days:
            # Skip if within break
            if any(start <= current_date <= end for start, end in break_ranges):
                current_date += timedelta(days=1)
                continue
            lecture_dates.append(current_date)
        current_date += timedelta(days=1)
        if current_date > end_date:
            break

    # Format dates
    schedule[section] = [d.strftime("%d-%b (%a)") for d in sorted(lecture_dates)]

# Create DataFrame
# Sort and create lecture schedule
# lecture_dates = sorted(lecture_dates)
schedule_df = pd.DataFrame({
    "#": [f"L{i+1}" for i in range(len(lecture_dates))],
    section: [d.strftime("%d-%b (%a)") for d in lecture_dates]
})

# Lab schedule: assign to first 6 lectures for this example
lab_entries = [""] * len(lecture_dates)
for i in [1, 2, 3, 5, 6, 7, 8, 9]:  # sample positions
    lab_entries[i] = f"Lab {i}"

# Assignments every other Monday starting from L2 (index 1)
assignments = []
assignment_labels = []
for i in range(2, len(lecture_dates), 2):
    if len(assignments) >= 5:
        break
    due_date = lecture_dates[i] + timedelta(days=1)
    # Skip if due falls in spring break
    if any(start <= due_date <= end for start, end in break_ranges):
        continue
    assignments.append((i, due_date))
    assignment_labels.append(f"A{len(assignments)} (Due: {due_date.strftime('%b %d')})")

assignment_column = [""] * len(lecture_dates)
project_column = [""] * len(lecture_dates)

# Add assignment and project milestone +1 week after each assignment
for idx, (lecture_idx, due_date) in enumerate(assignments):
    assignment_column[lecture_idx] = assignment_labels[idx]
    proj_idx = lecture_idx + 0
    if proj_idx < len(project_column):
        project_column[proj_idx] = f"Ungraded Milestone {idx+1}"

# Final presentations: last two lectures
project_column[-2] = "Presentation"
project_column[-1] = "Final Project Report + Presentation"

# Participation on second to last class
participation_column = [""] * len(lecture_dates)
participation_column[-2] = "Participation 1 + Participation 2"

# Add to schedule DataFrame
schedule_df["Lab (Due)"] = lab_entries
schedule_df["Assignments"] = assignment_column
schedule_df["Project Milestones"] = project_column
schedule_df["Participation"] = participation_column

# Export
output_file = f"./data/{semester}_schedule_oncampus.xlsx"
schedule_df.to_excel(output_file, index=False)
# Display HTML
HTML(schedule_df.to_html(index=False))
```